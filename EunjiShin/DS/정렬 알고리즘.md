### 선택 정렬 (Selection Sort)

- 현재 인덱스에 저장될 값을 찾아 정렬하는 방식

  - 현재 위치에 저장될 값의 크기가 작다면 최소 선택 정렬 : 오름차순 정렬
  - 현재 위치에 저장될 값의 크기가 크다면 최대 선택 정렬 : 내림차순 정렬

- 기본 로직

1. 인덱스 맨 앞부터 전부 돌면서 현재 이후 값들의 최소값을 찾는다
2. 최소값 찾으면 현재 인덱스 값과 바꾼다
3. 1,2를 반복한다

- 시간복잡도
  : 전체 비교 필요! O(n^2)

<br>

### 삽입 정렬 (Insertion Sort)

- 새로운 원소 값을 현재 인덱스 이후의 값들과 비교하여 들어갈 위치를 찾는 방식

  - 배열의 재배열!
  - 정렬 대상을 하나씩 늘리며 비교 = 해당 위치 앞까지 비교

- 기본 로직

1. 두번째 인덱스부터 시작 - 현재 인덱스를 변수로 저장 & 비교 인덱스는 현재 인덱스-1
2. 새로운 원소값과 비교 인덱스의 값을 비교
   2-1. 새로운 원소가 작다면 현재 인덱스에 비교 인덱스 값 저장 & 비교 인덱스 -1
   2-2. 새로운 원소가 크다면 비교 인덱스+1에 원소 저장

- 시간복잡도
  : 마지막 인덱스가 i라고 가정, i-1까지 올 때 최악
  : 즉 데이터 개수가 n개일 때 n-1번의 반복 필요
  : (n(n-2))/2 = O(n^2)

<br>

### 합병 정렬 (Merge Sort)

- 분할 정복 기법(Divide and Conquer) 사용

  - 문제를 2개로 분할 -> 정렬 후 -> 각각을 합쳐서 해결하는 방식
  - 분할은 각 문제(배열)의 크기가 1보다 작거나 같을 때까지 반복

- 기본 로직

  - 분할 : 제일 왼쪽 index = left, 제일 오른쪽 index = right
    1. 현재 배열을 2개로 분할한다. A 크기 : (mid-left+1) & B 크기 : (right-mid)
    2. mid = 0 || mid = 1까지 반복
  - 합병
    1. 분할된 두 배열을 처음부터 돌면서 각각의 인덱스 값을 비교한다. A[i], B[j]에서 시작
    2. 비교 후 더 작은 값을 새로운 배열 C에 저장한다
    3. 더 작은 값을 가진 배열의 인덱스를 증가시켜 다음 값과 다시 비교한다. Ex. A[i+2], B[j]
    4. i, j 중 하나가 각 배열의 끝에 도달할 때까지 1~3을 반복한다.
  - 재귀
    1. 배열의 중간값((left+right)/2)을 구한다
    2. A[left, mid]에서 Merge sorting을 수행한다
    3. A[mid+1, right]에서 Merge sorting을 수행한다
    4. A left, mid, right에 대해 Merge를 수행한다

- 시간복잡도
  : 2/n 사이즈 배열을 원소 한쌍씩 비교하니까 n
  : 순환 호출 - 합병은 트리 레벨이므로 log2n (밑이 2)
  : O(nlogn)

<br>

### 힙 정렬 (Heap Sort)

- 완전이진트리 자료구조 '힙'을 이용한 정렬

  - 최대힙 또는 최소힙 만든 후 모으면 정렬된다
  - n개 요소로 완전이진트리 만들기 -> 최대힙 만들기 -> 하나씩 꺼내서 배열의 뒤부터 삽입(내림차순)

- 기본 로직

  - 힙 정렬 알고리즘
    1. n개 요소로 완전이진트리 만들기
    2. 최대 힙 만들기
    3. 힙에서 하나씩 요소를 꺼내 배열의 뒤부터 삽입(내림차순)
    4. 힙에서 삭제는 최대값부터 삭제
  - 최대힙 구현
    1. 정렬할 n개 요소를 1차원 배열에 저장
    2. 최대 힙 삽입 : 새로운 노드를 마지막 노드에 저장한 후 부모 노드들과 비교 & 교환하면서 위치 찾기
    3. 최대 힙 삭제 : 최대 힙의 최대값은 항상 루트 노드 = 삭제된 루트 노드 위치에 힙의 마지막 노드를 가져온 후, 비교하며 힙 재구성

- 시간복잡도
  : 힙 재구성시 레빌 logN에 대해 N번 연산 필요
  : O(nlogn)

<br>

### 퀵 정렬 (Quick Sort)

- 분할 정복 기법(Divide and Conquer) 사용, 다른 원소와의 비교를 통해 정렬한다

  - pivot point 기준값을 이용한 순환적 기법
  - 순환 호출이 진행될 때마다 최소 하나의 원소의 위치가 정해진다

- 기본 로직

  - 분할
    1. 배열 안에서 한 요소(pivot point) 선택
    2. 피봇값과 배열값을 비교하면서 피봇 기준으로 작은건 왼쪽, 큰건 오른쪽으로 이동
  - 정복
    1. 피봇을 제외한 분할된 부분 배열, 왼쪽 배열과 오른쪽 배열에 대해 부분 배열의 크기가 0또는 1이 될 때까지 순환 호출로 각각 분할/정복 과정 반복
  - 결합
    1. 정렬된 부분 배열들을 하나의 배열로 합친다

- 시간복잡도
  : 원소 개수 n = 2^k일 때, 순환 호출의 깊이는 log2n (밑이 2)
  : 각 순환 호출마다 전체를 비교하므로 N
  : O(nlogn)
